# Node-RED Spec Tests Diff
This file is automatically generated by the script `scripts/specs_diff.py` to compare the specification compliance of EdgeLink and Node-RED nodes. 
## common nodes
### inject
| Status | Spec Test |
| --- | --- |
| :white_check_mark: | ~~inject node inject id of flow as environment variable~~ |
| :white_check_mark: | ~~inject node inject id of flow as environment variable~~ |
| :white_check_mark: | ~~inject node inject id of group as environment variable~~ |
| :white_check_mark: | ~~inject node inject id of group as environment variable by substitution~~ |
| :white_check_mark: | ~~inject node inject id of node as environment variable~~ |
| :white_check_mark: | ~~inject node inject id of node as environment variable by substitution~~ |
| :white_check_mark: | ~~inject node inject name of flow as environment variable~~ |
| :white_check_mark: | ~~inject node inject name of flow as environment variable by substitution~~ |
| :white_check_mark: | ~~inject node inject name of group as environment variable~~ |
| :white_check_mark: | ~~inject node inject name of group as environment variable by substitution~~ |
| :white_check_mark: | ~~inject node inject name of node as environment variable~~ |
| :white_check_mark: | ~~inject node inject name of node as environment variable by substitution~~ |
| :white_check_mark: | ~~inject node inject path of node as environment variable~~ |
| :white_check_mark: | ~~inject node inject path of node as environment variable by substitution~~ |
| :white_check_mark: | ~~inject node inject value (bin)~~ |
| :white_check_mark: | ~~inject node inject value (bool)~~ |
| :white_check_mark: | ~~inject node inject value (json)~~ |
| :white_check_mark: | ~~inject node inject value (num)~~ |
| :white_check_mark: | ~~inject node inject value (str)~~ |
| :white_check_mark: | ~~inject node inject value of environment variable~~ |
| :white_check_mark: | ~~inject node sets the value of flow context property~~ |
| :white_check_mark: | ~~inject node should inject multiple properties~~ |
| :white_check_mark: | ~~inject node should inject multiple properties using legacy props if needed~~ |
| :white_check_mark: | ~~inject node should inject once with 500 msec. delay~~ |
| :white_check_mark: | ~~inject node should inject once with default delay~~ |
| :white_check_mark: | ~~inject node should inject once with default delay property~~ |
| :white_check_mark: | ~~inject node should inject once with delay of two seconds~~ |
| :white_check_mark: | ~~inject node should inject once with delay of two seconds and repeatedly~~ |
| :white_check_mark: | ~~inject node should inject repeatedly~~ |
| :white_check_mark: | ~~inject node should inject with cron~~ |
| :x: | **inject node post should fail for invalid node** |
| :x: | **inject node post should inject custom properties in posted message** |
| :x: | **inject node post should inject message** |
| :x: | **inject node sets the value of global context property** |
| :x: | **inject node sets the value of persistable flow & global context property** |
| :x: | **inject node sets the value of persistable flow context property** |
| :x: | **inject node sets the value of persistable global context property** |
| :x: | **inject node sets the value of two persistable flow context property** |
| :x: | **inject node sets the value of two persistable global context property** |
| :x: | **inject node sets the value of two persistable global context property** |
| :x: | **inject node should inject custom properties in message** |
| :x: | **inject node should report invalid JSONata expression** |
### catch
| Status | Spec Test |
| --- | --- |
| :white_check_mark: | ~~catch Node should output a message when called~~ |
### link
| Status | Spec Test |
| --- | --- |
| :white_check_mark: | ~~link Node link-call node should allow nested link-call flows~~ |
| :white_check_mark: | ~~link Node link-call node should call link-in node by name and get response~~ |
| :white_check_mark: | ~~link Node link-call node should call static link-in node and get response~~ |
| :white_check_mark: | ~~link Node should be linked~~ |
| :white_check_mark: | ~~link Node should be linked from multiple nodes~~ |
| :white_check_mark: | ~~link Node should be linked to multiple nodes~~ |
| :white_check_mark: | ~~link Node should be loaded (link in)~~ |
| :white_check_mark: | ~~link Node should be loaded (link out)~~ |
| :x: | **link Node link-call node should not raise error after deploying a name change to a duplicate link-in node** |
| :x: | **link Node link-call node should raise error due to multiple targets on different tabs** |
| :x: | **link Node link-call node should raise error due to multiple targets on same tab** |
| :x: | **link Node link-call node should timeout waiting for link return** |
## function nodes
### function
| Status | Spec Test |
| --- | --- |
| :white_check_mark: | ~~function node should allow accessing env vars~~ |
| :white_check_mark: | ~~function node should allow accessing node.id~~ |
| :white_check_mark: | ~~function node should allow accessing node.id and node.name and node.outputCount~~ |
| :white_check_mark: | ~~function node should allow accessing node.name~~ |
| :white_check_mark: | ~~function node should allow input to be discarded by returning null~~ |
| :white_check_mark: | ~~function node should clone first message sent using send() - array 1~~ |
| :white_check_mark: | ~~function node should clone first message sent using send() - array 2~~ |
| :white_check_mark: | ~~function node should clone first message sent using send() - array 3~~ |
| :white_check_mark: | ~~function node should clone first message sent using send() - array 3~~ |
| :white_check_mark: | ~~function node should clone single message sent using send()~~ |
| :white_check_mark: | ~~function node should drop and log non-object message types - array~~ |
| :white_check_mark: | ~~function node should drop and log non-object message types - boolean~~ |
| :white_check_mark: | ~~function node should drop and log non-object message types - buffer~~ |
| :white_check_mark: | ~~function node should drop and log non-object message types - number~~ |
| :white_check_mark: | ~~function node should drop and log non-object message types - string~~ |
| :white_check_mark: | ~~function node should execute initialization~~ |
| :white_check_mark: | ~~function node should get flow context~~ |
| :white_check_mark: | ~~function node should get flow context~~ |
| :white_check_mark: | ~~function node should get global context~~ |
| :white_check_mark: | ~~function node should get global context~~ |
| :white_check_mark: | ~~function node should get keys in default persistable node context~~ |
| :white_check_mark: | ~~function node should get keys in flow context~~ |
| :white_check_mark: | ~~function node should get keys in global context~~ |
| :white_check_mark: | ~~function node should get keys in node context~~ |
| :white_check_mark: | ~~function node should get keys in persistable flow context (w/ callback)~~ |
| :white_check_mark: | ~~function node should get keys in persistable flow context (w/o callback)~~ |
| :white_check_mark: | ~~function node should get keys in persistable node context (w/ callback)~~ |
| :white_check_mark: | ~~function node should get keys in persistable node context (w/o callback)~~ |
| :white_check_mark: | ~~function node should get node context~~ |
| :white_check_mark: | ~~function node should get persistable flow context (w/ callback)~~ |
| :white_check_mark: | ~~function node should get persistable flow context (w/o callback)~~ |
| :white_check_mark: | ~~function node should get persistable global context (w/ callback)~~ |
| :white_check_mark: | ~~function node should get persistable global context (w/ callback)~~ |
| :white_check_mark: | ~~function node should get persistable global context (w/o callback)~~ |
| :white_check_mark: | ~~function node should get persistable global context (w/o callback)~~ |
| :white_check_mark: | ~~function node should get persistable node context (w/ callback)~~ |
| :white_check_mark: | ~~function node should get persistable node context (w/o callback)~~ |
| :white_check_mark: | ~~function node should handle clearInterval()~~ |
| :white_check_mark: | ~~function node should handle null amongst valid messages~~ |
| :white_check_mark: | ~~function node should handle setInterval()~~ |
| :white_check_mark: | ~~function node should handle setTimeout()~~ |
| :white_check_mark: | ~~function node should not clone single message sent using send(,false)~~ |
| :white_check_mark: | ~~function node should pass through _topic~~ |
| :white_check_mark: | ~~function node should send returned message~~ |
| :white_check_mark: | ~~function node should send returned message using send()~~ |
| :white_check_mark: | ~~function node should send returned message using send()~~ |
| :white_check_mark: | ~~function node should send to multiple messages~~ |
| :white_check_mark: | ~~function node should send to multiple outputs~~ |
| :white_check_mark: | ~~function node should set default persistable node context~~ |
| :white_check_mark: | ~~function node should set flow context~~ |
| :white_check_mark: | ~~function node should set global context~~ |
| :white_check_mark: | ~~function node should set node context~~ |
| :white_check_mark: | ~~function node should set persistable flow context (w/ callback)~~ |
| :white_check_mark: | ~~function node should set persistable flow context (w/o callback)~~ |
| :white_check_mark: | ~~function node should set persistable global context (w/ callback)~~ |
| :white_check_mark: | ~~function node should set persistable global context (w/o callback)~~ |
| :white_check_mark: | ~~function node should set persistable node context (w callback)~~ |
| :white_check_mark: | ~~function node should set persistable node context (w/o callback)~~ |
| :white_check_mark: | ~~function node should set two persistable flow context (w/ callback)~~ |
| :white_check_mark: | ~~function node should set two persistable flow context (w/o callback)~~ |
| :white_check_mark: | ~~function node should set two persistable node context (single call, w/o callback)~~ |
| :white_check_mark: | ~~function node should set two persistable node context (w callback)~~ |
| :white_check_mark: | ~~function node should set two persistable node context (w/o callback)~~ |
| :white_check_mark: | ~~function node should wait completion of initialization~~ |
| :x: | **function node Logger should catch thrown number** |
| :x: | **function node Logger should catch thrown object (bad practice)** |
| :x: | **function node Logger should catch thrown string** |
| :x: | **function node Logger should log a Debug Message** |
| :x: | **function node Logger should log a Debug Message - initialise** |
| :x: | **function node Logger should log a Trace Message** |
| :x: | **function node Logger should log a Trace Message - initialise** |
| :x: | **function node Logger should log a Warning Message** |
| :x: | **function node Logger should log a Warning Message - initialise** |
| :x: | **function node Logger should log an Error Message** |
| :x: | **function node Logger should log an Error Message - initialise** |
| :x: | **function node Logger should log an Info Message** |
| :x: | **function node Logger should log an Info Message - initialise** |
| :x: | **function node check if default function timeout settings are recognized** |
| :x: | **function node externalModules should fail if module variable name clashes with sandbox builtin** |
| :x: | **function node externalModules should fail if using OS module with functionExternalModules set to false** |
| :x: | **function node externalModules should fail if using OS module without it listed in libs** |
| :x: | **function node externalModules should require the OS module** |
| :x: | **function node finalize function should allow accessing node.id and node.name and node.outputCount** |
| :x: | **function node finalize function should execute** |
| :x: | **function node init function should allow accessing node.id and node.name and node.outputCount and sending message** |
| :x: | **function node init function should delay handling messages until init completes** |
| :x: | **function node should be loaded** |
| :x: | **function node should do something with the catch node** |
| :x: | **function node should handle and log script error** |
| :x: | **function node should handle error on get keys in persistable context** |
| :x: | **function node should handle error on get persistable context** |
| :x: | **function node should handle error on set persistable context** |
| :x: | **function node should handle node.on()** |
| :x: | **function node should set two persistable node context (single call, w callback)** |
| :x: | **function node should timeout if timeout is set** |
| :x: | **function node should use the same Date object from outside the sandbox** |
### switch
| Status | Spec Test |
| --- | --- |
| :white_check_mark: | ~~switch Node handles more than one switch statement~~ |
| :white_check_mark: | ~~switch Node sends a message when the "else/otherwise" statement is selected~~ |
| :white_check_mark: | ~~switch Node sends nothing when input is false and checking for true~~ |
| :white_check_mark: | ~~switch Node sends nothing when input is false and checking for true~~ |
| :white_check_mark: | ~~switch Node should be able to use $I in JSONata expression~~ |
| :white_check_mark: | ~~switch Node should be able to use $N in JSONata expression~~ |
| :white_check_mark: | ~~switch Node should be loaded with some defaults~~ |
| :white_check_mark: | ~~switch Node should check JSONata expression is true~~ |
| :white_check_mark: | ~~switch Node should check if input is indeed false~~ |
| :white_check_mark: | ~~switch Node should check if input is indeed not null~~ |
| :white_check_mark: | ~~switch Node should check if input is indeed null~~ |
| :white_check_mark: | ~~switch Node should check if input is indeed undefined~~ |
| :white_check_mark: | ~~switch Node should check if input is true~~ |
| :white_check_mark: | ~~switch Node should check if payload NOT equals given numeric value~~ |
| :white_check_mark: | ~~switch Node should check if payload NOT equals given value~~ |
| :white_check_mark: | ~~switch Node should check if payload contains given value~~ |
| :white_check_mark: | ~~switch Node should check if payload equals given numeric value~~ |
| :white_check_mark: | ~~switch Node should check if payload equals given value~~ |
| :white_check_mark: | ~~switch Node should check if payload if of type JSON string~~ |
| :white_check_mark: | ~~switch Node should check if payload if of type JSON string (and fail if not)~~ |
| :white_check_mark: | ~~switch Node should check if payload if of type array~~ |
| :white_check_mark: | ~~switch Node should check if payload if of type boolean false~~ |
| :white_check_mark: | ~~switch Node should check if payload if of type boolean true~~ |
| :white_check_mark: | ~~switch Node should check if payload if of type buffer~~ |
| :white_check_mark: | ~~switch Node should check if payload if of type null~~ |
| :white_check_mark: | ~~switch Node should check if payload if of type number~~ |
| :white_check_mark: | ~~switch Node should check if payload if of type number 0~~ |
| :white_check_mark: | ~~switch Node should check if payload if of type number Infinity~~ |
| :white_check_mark: | ~~switch Node should check if payload if of type number NaN~~ |
| :white_check_mark: | ~~switch Node should check if payload if of type object~~ |
| :white_check_mark: | ~~switch Node should check if payload if of type string~~ |
| :white_check_mark: | ~~switch Node should check if payload if of type undefined~~ |
| :white_check_mark: | ~~switch Node should check if payload is between given string values~~ |
| :white_check_mark: | ~~switch Node should check if payload is between given values~~ |
| :white_check_mark: | ~~switch Node should check if payload is between given values in "wrong" order~~ |
| :white_check_mark: | ~~switch Node should check if payload is empty (0)~~ |
| :white_check_mark: | ~~switch Node should check if payload is empty (array)~~ |
| :white_check_mark: | ~~switch Node should check if payload is empty (buffer)~~ |
| :white_check_mark: | ~~switch Node should check if payload is empty (non-empty array)~~ |
| :white_check_mark: | ~~switch Node should check if payload is empty (non-empty buffer)~~ |
| :white_check_mark: | ~~switch Node should check if payload is empty (non-empty object)~~ |
| :white_check_mark: | ~~switch Node should check if payload is empty (non-empty string)~~ |
| :white_check_mark: | ~~switch Node should check if payload is empty (null)~~ |
| :white_check_mark: | ~~switch Node should check if payload is empty (object)~~ |
| :white_check_mark: | ~~switch Node should check if payload is empty (string)~~ |
| :white_check_mark: | ~~switch Node should check if payload is empty (undefined)~~ |
| :white_check_mark: | ~~switch Node should check if payload is greater than given value~~ |
| :white_check_mark: | ~~switch Node should check if payload is greater than/equals given value~~ |
| :white_check_mark: | ~~switch Node should check if payload is greater than/equals given value~~ |
| :white_check_mark: | ~~switch Node should check if payload is less than given value~~ |
| :white_check_mark: | ~~switch Node should check if payload is not between given values~~ |
| :white_check_mark: | ~~switch Node should check if payload is not empty (0)~~ |
| :white_check_mark: | ~~switch Node should check if payload is not empty (array)~~ |
| :white_check_mark: | ~~switch Node should check if payload is not empty (buffer)~~ |
| :white_check_mark: | ~~switch Node should check if payload is not empty (non-empty array)~~ |
| :white_check_mark: | ~~switch Node should check if payload is not empty (non-empty buffer)~~ |
| :white_check_mark: | ~~switch Node should check if payload is not empty (non-empty object)~~ |
| :white_check_mark: | ~~switch Node should check if payload is not empty (non-empty string)~~ |
| :white_check_mark: | ~~switch Node should check if payload is not empty (null)~~ |
| :white_check_mark: | ~~switch Node should check if payload is not empty (object)~~ |
| :white_check_mark: | ~~switch Node should check if payload is not empty (string)~~ |
| :white_check_mark: | ~~switch Node should check if payload is not empty (undefined)~~ |
| :white_check_mark: | ~~switch Node should check if payload less than equals given value~~ |
| :white_check_mark: | ~~switch Node should check input against a previous value~~ |
| :white_check_mark: | ~~switch Node should check input against a previous value (2nd option)~~ |
| :white_check_mark: | ~~switch Node should handle JSONata expression~~ |
| :white_check_mark: | ~~switch Node should handle empty rule~~ |
| :white_check_mark: | ~~switch Node should handle env var expression~~ |
| :white_check_mark: | ~~switch Node should handle flow and global contexts with JSONata expression~~ |
| :white_check_mark: | ~~switch Node should handle flow context~~ |
| :white_check_mark: | ~~switch Node should handle global context~~ |
| :white_check_mark: | ~~switch Node should handle invalid jsonata expression~~ |
| :white_check_mark: | ~~switch Node should handle persistable flow and global contexts with JSONata expression~~ |
| :white_check_mark: | ~~switch Node should handle persistable flow context~~ |
| :white_check_mark: | ~~switch Node should handle persistable global context~~ |
| :white_check_mark: | ~~switch Node should match if a payload has a required property~~ |
| :white_check_mark: | ~~switch Node should match regex~~ |
| :white_check_mark: | ~~switch Node should match regex with ignore-case flag set true~~ |
| :white_check_mark: | ~~switch Node should not match if a payload does not have a required property~~ |
| :white_check_mark: | ~~switch Node should not match if the key is not a string~~ |
| :white_check_mark: | ~~switch Node should not match if the parent object does not exist - null~~ |
| :white_check_mark: | ~~switch Node should not match if the parent object does not exist - undefined~~ |
| :white_check_mark: | ~~switch Node should not match regex with ignore-case flag set false~~ |
| :white_check_mark: | ~~switch Node should not match regex with ignore-case flag unset~~ |
| :white_check_mark: | ~~switch Node should not repair message sequence for each port~~ |
| :white_check_mark: | ~~switch Node should repair message sequence for each port~~ |
| :white_check_mark: | ~~switch Node should return nothing when the payload does equal to desired numeric value~~ |
| :white_check_mark: | ~~switch Node should return nothing when the payload does equal to desired string~~ |
| :white_check_mark: | ~~switch Node should return nothing when the payload doesn't contain desired string~~ |
| :white_check_mark: | ~~switch Node should return nothing when the payload doesn't equal to desired numeric value~~ |
| :white_check_mark: | ~~switch Node should return nothing when the payload doesn't equal to desired string~~ |
| :white_check_mark: | ~~switch Node should return nothing when the payload doesn't match regex~~ |
| :white_check_mark: | ~~switch Node should return nothing when the payload is not greater than desired string~~ |
| :white_check_mark: | ~~switch Node should return nothing when the payload is not greater than desired string~~ |
| :white_check_mark: | ~~switch Node should return nothing when the payload is not less than desired string~~ |
| :white_check_mark: | ~~switch Node should take head of message sequence (no repair)~~ |
| :white_check_mark: | ~~switch Node should take head of message sequence (repair)~~ |
| :white_check_mark: | ~~switch Node should take slice of message sequence (no repair)~~ |
| :white_check_mark: | ~~switch Node should take tail of message sequence (no repair)~~ |
| :white_check_mark: | ~~switch Node should use a nested message property to compare nested message property - matches~~ |
| :white_check_mark: | ~~switch Node should use a nested message property to compare nested message property - no match~~ |
| :white_check_mark: | ~~switch Node should use a nested message property to compare value - matches~~ |
| :white_check_mark: | ~~switch Node should use a nested message property to compare value - no match~~ |
| :white_check_mark: | ~~switch Node stops after first statement~~ |
| :x: | **switch Node should handle too many pending messages** |
| :x: | **switch Node should repair message sequence for each port (overlap)** |
| :x: | **switch Node should return nothing when the payload doesn't contain desired string** |
| :x: | **switch Node should take head of message sequence (w. JSONata)** |
| :x: | **switch Node should take head of message sequence (w. context)** |
| :x: | **switch Node should take slice of message sequence (repair)** |
| :x: | **switch Node should take tail of message sequence (repair)** |
| :x: | **switch Node should treat non-existant msg property conditional as undefined** |
### change
| Status | Spec Test |
| --- | --- |
| :white_check_mark: | ~~change Node #change changes the number using global context property~~ |
| :white_check_mark: | ~~change Node #change changes the number using persistable global context property~~ |
| :white_check_mark: | ~~change Node #change changes the value - new rule format~~ |
| :white_check_mark: | ~~change Node #change changes the value and doesnt change type of the flow context for partial match~~ |
| :white_check_mark: | ~~change Node #change changes the value and doesnt change type of the message property for partial match~~ |
| :white_check_mark: | ~~change Node #change changes the value and doesnt change type of the persistable flow context for partial match~~ |
| :white_check_mark: | ~~change Node #change changes the value and type of the flow context if a complete match~~ |
| :white_check_mark: | ~~change Node #change changes the value and type of the message property if a complete match - boolean~~ |
| :white_check_mark: | ~~change Node #change changes the value and type of the message property if a complete match - number~~ |
| :white_check_mark: | ~~change Node #change changes the value and type of the persistable flow context if a complete match~~ |
| :white_check_mark: | ~~change Node #change changes the value of a multi-level message property~~ |
| :white_check_mark: | ~~change Node #change changes the value of the global context~~ |
| :white_check_mark: | ~~change Node #change changes the value of the message property~~ |
| :white_check_mark: | ~~change Node #change changes the value of the message property based on a regex~~ |
| :white_check_mark: | ~~change Node #change changes the value of the persistable global context~~ |
| :white_check_mark: | ~~change Node #change changes the value using boolean - boolean flow context~~ |
| :white_check_mark: | ~~change Node #change changes the value using boolean - boolean payload~~ |
| :white_check_mark: | ~~change Node #change changes the value using boolean - boolean persistable flow context~~ |
| :white_check_mark: | ~~change Node #change changes the value using boolean - string payload~~ |
| :white_check_mark: | ~~change Node #change changes the value using flow context property~~ |
| :white_check_mark: | ~~change Node #change changes the value using global context property~~ |
| :white_check_mark: | ~~change Node #change changes the value using msg property~~ |
| :white_check_mark: | ~~change Node #change changes the value using number - number flow context~~ |
| :white_check_mark: | ~~change Node #change changes the value using number - number payload~~ |
| :white_check_mark: | ~~change Node #change changes the value using number - number persistable flow context~~ |
| :white_check_mark: | ~~change Node #change changes the value using number - string payload~~ |
| :white_check_mark: | ~~change Node #change changes the value using persistable flow context property~~ |
| :white_check_mark: | ~~change Node #change changes the value using persistable global context property~~ |
| :white_check_mark: | ~~change Node #change env var changes the value using env property~~ |
| :white_check_mark: | ~~change Node #change sends unaltered message if a changed multi-level message property does not exist~~ |
| :white_check_mark: | ~~change Node #change sends unaltered message if the changed message property does not exist~~ |
| :white_check_mark: | ~~change Node #change supports regex groups~~ |
| :white_check_mark: | ~~change Node #change supports regex groups - new rule format~~ |
| :white_check_mark: | ~~change Node #delete deletes the value of a multi-level message property~~ |
| :white_check_mark: | ~~change Node #delete deletes the value of global context property~~ |
| :white_check_mark: | ~~change Node #delete deletes the value of persistable global context property~~ |
| :white_check_mark: | ~~change Node #delete deletes the value of the message property~~ |
| :white_check_mark: | ~~change Node #delete sends unaltered message if a deleted multi-level message property does not exist~~ |
| :white_check_mark: | ~~change Node #delete sends unaltered message if the deleted message property does not exist~~ |
| :white_check_mark: | ~~change Node #move moves the value of a message property object~~ |
| :white_check_mark: | ~~change Node #move moves the value of a message property object to a sub-property~~ |
| :white_check_mark: | ~~change Node #move moves the value of a message property object to itself~~ |
| :white_check_mark: | ~~change Node #move moves the value of a message sub-property object to a property~~ |
| :white_check_mark: | ~~change Node #move moves the value of the message property~~ |
| :white_check_mark: | ~~change Node #set changes the value to a boolean value~~ |
| :white_check_mark: | ~~change Node #set changes the value to a buffer object~~ |
| :white_check_mark: | ~~change Node #set changes the value to a js object~~ |
| :white_check_mark: | ~~change Node #set changes the value to a number~~ |
| :white_check_mark: | ~~change Node #set changes the value to flow context property~~ |
| :white_check_mark: | ~~change Node #set changes the value to global context property~~ |
| :white_check_mark: | ~~change Node #set changes the value to persistable flow context property~~ |
| :white_check_mark: | ~~change Node #set changes the value to persistable global context property~~ |
| :white_check_mark: | ~~change Node #set does not set other properties using = inside to property~~ |
| :white_check_mark: | ~~change Node #set doesn't set the value of a message property when the 'to' message property does not exist~~ |
| :white_check_mark: | ~~change Node #set env var sets the value using env property~~ |
| :white_check_mark: | ~~change Node #set env var sets the value using env property from group~~ |
| :white_check_mark: | ~~change Node #set env var sets the value using env property from nested group~~ |
| :white_check_mark: | ~~change Node #set env var sets the value using env property from tab~~ |
| :white_check_mark: | ~~change Node #set overrides the value of a message property when the 'to' message property does not exist~~ |
| :white_check_mark: | ~~change Node #set sets the message property to null when the 'to' message property equals null~~ |
| :white_check_mark: | ~~change Node #set sets the value and type of the message property~~ |
| :white_check_mark: | ~~change Node #set sets the value of a message property to another message property~~ |
| :white_check_mark: | ~~change Node #set sets the value of a message property using a nested property~~ |
| :white_check_mark: | ~~change Node #set sets the value of a message property using a nested property in flow context~~ |
| :white_check_mark: | ~~change Node #set sets the value of a multi-level message property to another multi-level message property~~ |
| :white_check_mark: | ~~change Node #set sets the value of a nested flow context property using a message property~~ |
| :white_check_mark: | ~~change Node #set sets the value of a nested message property using a message property~~ |
| :white_check_mark: | ~~change Node #set sets the value of an already set multi-level message property~~ |
| :white_check_mark: | ~~change Node #set sets the value of an empty multi-level message property~~ |
| :white_check_mark: | ~~change Node #set sets the value of global context property~~ |
| :white_check_mark: | ~~change Node #set sets the value of persistable global context property~~ |
| :white_check_mark: | ~~change Node #set sets the value of the message property~~ |
| :white_check_mark: | ~~change Node #set sets the value of the message property to the current timestamp~~ |
| :white_check_mark: | ~~change Node #set splits dot delimited properties into objects~~ |
| :white_check_mark: | ~~change Node - multiple rules applies multiple rules in order~~ |
| :white_check_mark: | ~~change Node - multiple rules can access persistable global & flow context property~~ |
| :white_check_mark: | ~~change Node - multiple rules can access two persistable flow context property~~ |
| :white_check_mark: | ~~change Node - multiple rules can access two persistable global context property~~ |
| :white_check_mark: | ~~change Node - multiple rules handles multiple rules~~ |
| :white_check_mark: | ~~change Node should load defaults if set to change~~ |
| :white_check_mark: | ~~change Node should load defaults if set to replace~~ |
| :white_check_mark: | ~~change Node should load node with defaults~~ |
| :white_check_mark: | ~~change Node should no-op if there are no rules~~ |
| :x: | **change Node #change reports invalid fromValue** |
| :x: | **change Node #change reports invalid regex** |
| :x: | **change Node #set changes the value using flow context with jsonata** |
| :x: | **change Node #set changes the value using global context with jsonata** |
| :x: | **change Node #set changes the value using jsonata** |
| :x: | **change Node #set changes the value using persistable flow context with jsonata** |
| :x: | **change Node #set changes the value using persistable global context with jsonata** |
| :x: | **change Node #set deep copies the property if selected** |
| :x: | **change Node #set reports invalid jsonata expression** |
| :x: | **change Node #set sets the value of a message property using a nested property in flow context** |
### range
| Status | Spec Test |
| --- | --- |
| :white_check_mark: | ~~range Node clamps numbers within a range - below min~~ |
| :white_check_mark: | ~~range Node clamps numbers within a range - over max~~ |
| :white_check_mark: | ~~range Node drops msg if in drop mode and input outside range~~ |
| :white_check_mark: | ~~range Node just passes on msg if payload not present~~ |
| :white_check_mark: | ~~range Node ranges numbers down such as centimetres to metres~~ |
| :white_check_mark: | ~~range Node ranges numbers up tenfold~~ |
| :white_check_mark: | ~~range Node reports if input is not a number~~ |
| :white_check_mark: | ~~range Node wraps numbers around say for degree/rotation reading 0~~ |
| :white_check_mark: | ~~range Node wraps numbers around say for degree/rotation reading 1/3~~ |
| :white_check_mark: | ~~range Node wraps numbers around say for degree/rotation reading 1/4~~ |
| :white_check_mark: | ~~range Node wraps numbers down say for degree/rotation reading 1/2~~ |
| :white_check_mark: | ~~range Node wraps numbers down say for degree/rotation reading 1/4~~ |
| :x: | **range Node should load some defaults** |
### template
| Status | Spec Test |
| --- | --- |
| :white_check_mark: | ~~template node env var should modify payload from env variable~~ |
| :white_check_mark: | ~~template node should be able to overwrite msg.template using the template from msg.template~~ |
| :white_check_mark: | ~~template node should handle block contexts objects~~ |
| :white_check_mark: | ~~template node should handle deeper objects~~ |
| :white_check_mark: | ~~template node should handle escape characters in Mustache format and JSON output mode~~ |
| :white_check_mark: | ~~template node should handle if the field isn't set~~ |
| :white_check_mark: | ~~template node should handle missing node context~~ |
| :white_check_mark: | ~~template node should handle nested context tags - property not set~~ |
| :white_check_mark: | ~~template node should handle nested context tags - property set~~ |
| :white_check_mark: | ~~template node should modify flow context~~ |
| :white_check_mark: | ~~template node should modify global context~~ |
| :white_check_mark: | ~~template node should modify payload from flow context~~ |
| :white_check_mark: | ~~template node should modify payload from global context~~ |
| :white_check_mark: | ~~template node should modify payload from msg.template~~ |
| :white_check_mark: | ~~template node should modify payload from persistable flow & global context~~ |
| :white_check_mark: | ~~template node should modify payload from persistable flow context~~ |
| :white_check_mark: | ~~template node should modify payload from persistable global context~~ |
| :white_check_mark: | ~~template node should modify payload from two persistable flow context~~ |
| :white_check_mark: | ~~template node should modify payload from two persistable global context~~ |
| :white_check_mark: | ~~template node should modify payload in plain text mode~~ |
| :white_check_mark: | ~~template node should modify payload using node-configured template~~ |
| :white_check_mark: | ~~template node should modify persistable flow context~~ |
| :white_check_mark: | ~~template node should modify persistable global context~~ |
| :white_check_mark: | ~~template node should modify the configured property using msg.template~~ |
| :white_check_mark: | ~~template node should raise error if passed bad template~~ |
### delay
| Status | Spec Test |
| --- | --- |
| :white_check_mark: | ~~delay Node calls done when queue is flushed (queue/timed)~~ |
| :white_check_mark: | ~~delay Node calls done when queue is reset (queue/timed)~~ |
| :white_check_mark: | ~~delay Node calls done when queued message is cleared (type: delay)~~ |
| :white_check_mark: | ~~delay Node calls done when queued message is cleared (type: delayv)~~ |
| :white_check_mark: | ~~delay Node calls done when queued message is cleared (type: random)~~ |
| :white_check_mark: | ~~delay Node calls done when queued message is emitted (type: delay)~~ |
| :white_check_mark: | ~~delay Node calls done when queued message is emitted (type: delay)~~ |
| :white_check_mark: | ~~delay Node calls done when queued message is emitted (type: delayv)~~ |
| :white_check_mark: | ~~delay Node calls done when queued message is flushed (type: delay)~~ |
| :white_check_mark: | ~~delay Node calls done when queued message is flushed (type: delayv)~~ |
| :white_check_mark: | ~~delay Node calls done when queued message is flushed (type: random)~~ |
| :white_check_mark: | ~~delay Node calls done when queued messages are sent (queue)~~ |
| :white_check_mark: | ~~delay Node calls done when queued messages are sent (timed)~~ |
| :white_check_mark: | ~~delay Node calls done when rated message is emitted (drop: false)~~ |
| :white_check_mark: | ~~delay Node calls done when rated message is emitted (drop: true)~~ |
| :white_check_mark: | ~~delay Node calls done when rated message is flushed~~ |
| :white_check_mark: | ~~delay Node can flush delay queue~~ |
| :white_check_mark: | ~~delay Node can flush rate limit queue~~ |
| :white_check_mark: | ~~delay Node can full flush and reset rate limit queue~~ |
| :white_check_mark: | ~~delay Node can part flush and reset rate limit queue~~ |
| :white_check_mark: | ~~delay Node can part flush delay queue~~ |
| :white_check_mark: | ~~delay Node can part flush rate limit queue~~ |
| :white_check_mark: | ~~delay Node can part push to front of rate limit queue~~ |
| :white_check_mark: | ~~delay Node can reset delay queue~~ |
| :white_check_mark: | ~~delay Node can reset rate limit queue~~ |
| :white_check_mark: | ~~delay Node delays the message in days~~ |
| :white_check_mark: | ~~delay Node delays the message in days~~ |
| :white_check_mark: | ~~delay Node delays the message in hours~~ |
| :white_check_mark: | ~~delay Node delays the message in hours~~ |
| :white_check_mark: | ~~delay Node delays the message in milliseconds~~ |
| :white_check_mark: | ~~delay Node delays the message in minutes~~ |
| :white_check_mark: | ~~delay Node delays the message in seconds~~ |
| :white_check_mark: | ~~delay Node handles delay queue~~ |
| :white_check_mark: | ~~delay Node handles timed queue~~ |
| :white_check_mark: | ~~delay Node limits the message rate to 1 per 2 seconds~~ |
| :white_check_mark: | ~~delay Node limits the message rate to 1 per 2 seconds, 4 seconds, with drop~~ |
| :white_check_mark: | ~~delay Node limits the message rate to 1 per second~~ |
| :white_check_mark: | ~~delay Node limits the message rate to 1 per second, 4 seconds, with drop~~ |
| :white_check_mark: | ~~delay Node limits the message rate to 2 per second, 5 seconds, with drop~~ |
| :white_check_mark: | ~~delay Node limits the message rate to 2 per second, 5 seconds, with drop, 2nd output~~ |
| :white_check_mark: | ~~delay Node limits the message rate to 2 per seconds, 2 seconds~~ |
| :white_check_mark: | ~~delay Node limits the message rate using msg.rate~~ |
| :white_check_mark: | ~~delay Node limits the message rate with drop using msg.rate~~ |
| :white_check_mark: | ~~delay Node randomly delays the message in milliseconds~~ |
| :white_check_mark: | ~~delay Node randomly delays the message in minutes~~ |
| :white_check_mark: | ~~delay Node randomly delays the message in seconds~~ |
| :white_check_mark: | ~~delay Node sending a msg with reset to empty queue doesnt send anything~~ |
| :white_check_mark: | ~~delay Node should be able to set rate to hour~~ |
| :white_check_mark: | ~~delay Node should be able to set rate to minute~~ |
| :white_check_mark: | ~~delay Node should be loaded~~ |
| :white_check_mark: | ~~delay Node variable delay is the default if msg.delay not specified~~ |
| :white_check_mark: | ~~delay Node variable delay is zero if msg.delay is negative~~ |
| :white_check_mark: | ~~delay Node variable delay is zero if msg.delay is zero~~ |
| :white_check_mark: | ~~delay Node variable delay set by msg.delay the message in milliseconds~~ |
### trigger
| Status | Spec Test |
| --- | --- |
| :white_check_mark: | ~~trigger node should be able output the 2nd payload~~ |
| :white_check_mark: | ~~trigger node should be able output the 2nd payload and handle multiple topics~~ |
| :white_check_mark: | ~~trigger node should be able to apply mustache templates to payloads~~ |
| :white_check_mark: | ~~trigger node should be able to extend the delay~~ |
| :white_check_mark: | ~~trigger node should be able to extend the delay (but with no 2nd output)~~ |
| :white_check_mark: | ~~trigger node should be able to extend the delay and output the most recent payload~~ |
| :white_check_mark: | ~~trigger node should be able to not output anything on first trigger~~ |
| :white_check_mark: | ~~trigger node should be able to not output anything on second edge~~ |
| :white_check_mark: | ~~trigger node should be able to reset correctly having not output anything on second edge~~ |
| :white_check_mark: | ~~trigger node should be able to send 2nd message to a 2nd output~~ |
| :white_check_mark: | ~~trigger node should be able to set a repeat, and clear loop by reset~~ |
| :white_check_mark: | ~~trigger node should be able to set delay in hours~~ |
| :white_check_mark: | ~~trigger node should be able to set delay in minutes~~ |
| :white_check_mark: | ~~trigger node should be able to set delay in seconds~~ |
| :white_check_mark: | ~~trigger node should be able to set infinite timeout, and clear timeout~~ |
| :white_check_mark: | ~~trigger node should be able to set infinite timeout, and clear timeout by boolean false~~ |
| :white_check_mark: | ~~trigger node should be able to set infinite timeout, and clear timeout by boolean true~~ |
| :white_check_mark: | ~~trigger node should be able to set infinite timeout, and clear timeout by message~~ |
| :white_check_mark: | ~~trigger node should be loaded with correct defaults~~ |
| :white_check_mark: | ~~trigger node should handle multiple other properties individually if asked to do so~~ |
| :white_check_mark: | ~~trigger node should handle multiple topics as one if not asked to handle~~ |
| :white_check_mark: | ~~trigger node should handle multiple topics individually if asked to do so~~ |
| :white_check_mark: | ~~trigger node should handle multiple topics individually, and extend one, if asked to do so~~ |
| :white_check_mark: | ~~trigger node should handle string null as null~~ |
| :white_check_mark: | ~~trigger node should handle string null as null on op2~~ |
| :white_check_mark: | ~~trigger node should handle true and false as strings and delay of 0~~ |
| :white_check_mark: | ~~trigger node should ignore any other inputs while triggered if extend is false~~ |
| :white_check_mark: | ~~trigger node should output 1 then 0 when triggered (default)~~ |
| :white_check_mark: | ~~trigger node should output 1st value when triggered (bool)~~ |
| :white_check_mark: | ~~trigger node should output 1st value when triggered (json)~~ |
| :white_check_mark: | ~~trigger node should output 1st value when triggered (num)~~ |
| :white_check_mark: | ~~trigger node should output 1st value when triggered (str)~~ |
| :white_check_mark: | ~~trigger node should output 2st value when triggered (bool)~~ |
| :white_check_mark: | ~~trigger node should output 2st value when triggered (json)~~ |
| :white_check_mark: | ~~trigger node should output 2st value when triggered (num)~~ |
| :white_check_mark: | ~~trigger node should output 2st value when triggered (str)~~ |
| :x: | **trigger node messaging API should call done() when first message has been processed** |
| :x: | **trigger node messaging API should call done() when it receives reset message** |
| :x: | **trigger node should be able to return things from flow and global context variables** |
| :x: | **trigger node should be able to return things from multiple persistable flow & global context variables** |
| :x: | **trigger node should be able to return things from multiple persistable flow context variables** |
| :x: | **trigger node should be able to return things from multiple persistable global context variables** |
| :x: | **trigger node should be able to return things from persistable flow and global context variables** |
| :x: | **trigger node should ignore msg.delay if overrideDelay not set** |
| :x: | **trigger node should output 1st value when triggered (bin)** |
| :x: | **trigger node should output 1st value when triggered (date)** |
| :x: | **trigger node should output 1st value when triggered (date)** |
| :x: | **trigger node should output 1st value when triggered (env)** |
| :x: | **trigger node should output 2st value when triggered (bin)** |
| :x: | **trigger node should output 2st value when triggered (date)** |
| :x: | **trigger node should output 2st value when triggered (date)** |
| :x: | **trigger node should output 2st value when triggered (env)** |
| :x: | **trigger node should use msg.delay if overrideDelay is set** |
### rbe
| Status | Spec Test |
| --- | --- |
| :white_check_mark: | ~~rbe node should ignore multiple topics if told to (rbe)~~ |
| :white_check_mark: | ~~rbe node should not send output if more than x away from original value (narrowband in step mode)~~ |
| :white_check_mark: | ~~rbe node should not send output if more than x away from original value (narrowband)~~ |
| :white_check_mark: | ~~rbe node should not send output if x away or greater from original value (narrowbandEq)~~ |
| :white_check_mark: | ~~rbe node should only send output if another chosen property changes - foo (rbe)~~ |
| :white_check_mark: | ~~rbe node should only send output if more than x away from original value (deadband)~~ |
| :white_check_mark: | ~~rbe node should only send output if more than x% away from original value (deadband)~~ |
| :white_check_mark: | ~~rbe node should only send output if payload changes - ignoring first value (rbei)~~ |
| :white_check_mark: | ~~rbe node should only send output if payload changes - with multiple topics (rbe)~~ |
| :white_check_mark: | ~~rbe node should only send output if x away from original value (deadbandEq)~~ |
| :white_check_mark: | ~~rbe node should send output if gap is 0 and input doesnt change (narrowband)~~ |
| :white_check_mark: | ~~rbe node should send output if queue is reset (rbe)~~ |
| :x: | **rbe node should be loaded with correct defaults** |
| :x: | **rbe node should warn if no number found in deadband mode** |
### exec
| Status | Spec Test |
| --- | --- |
| :white_check_mark: | ~~exec node calling exec should be able to kill a long running command~~ |
| :white_check_mark: | ~~exec node calling exec should be able to kill a long running command - SIGINT~~ |
| :white_check_mark: | ~~exec node calling exec should be able to return a binary buffer~~ |
| :white_check_mark: | ~~exec node calling exec should be able to timeout a long running command~~ |
| :white_check_mark: | ~~exec node calling exec should exec a simple command~~ |
| :white_check_mark: | ~~exec node calling exec should exec a simple command with appended value from message~~ |
| :white_check_mark: | ~~exec node calling exec should exec a simple command with extra parameters~~ |
| :white_check_mark: | ~~exec node calling exec should preserve existing properties on msg object~~ |
| :white_check_mark: | ~~exec node calling exec should preserve existing properties on msg object for a failing command~~ |
| :white_check_mark: | ~~exec node calling exec should return the rc for a failing command~~ |
| :white_check_mark: | ~~exec node calling spawn should be able to kill a long running command~~ |
| :white_check_mark: | ~~exec node calling spawn should be able to kill a long running command - SIGINT~~ |
| :white_check_mark: | ~~exec node calling spawn should be able to timeout a long running command~~ |
| :white_check_mark: | ~~exec node calling spawn should preserve existing properties on msg object~~ |
| :white_check_mark: | ~~exec node calling spawn should preserve existing properties on msg object for a failing command~~ |
| :white_check_mark: | ~~exec node calling spawn should return an error for a bad command~~ |
| :white_check_mark: | ~~exec node calling spawn should return an error for a failing command~~ |
| :white_check_mark: | ~~exec node calling spawn should spawn a simple command~~ |
| :white_check_mark: | ~~exec node calling spawn should spawn a simple command and return binary buffer~~ |
| :white_check_mark: | ~~exec node calling spawn should spawn a simple command with a non string payload parameter~~ |
| :white_check_mark: | ~~exec node calling spawn should work if passed multiple words to spawn command~~ |
| :white_check_mark: | ~~exec node should be loaded with any defaults~~ |
## sequence nodes
### spilt node
| Status | Spec Test |
| --- | --- |
| :white_check_mark: | ~~SPLIT node should be loaded~~ |
| :white_check_mark: | ~~SPLIT node should ceil count value when msg.payload type is Buffer~~ |
| :white_check_mark: | ~~SPLIT node should ceil count value when msg.payload type is string~~ |
| :white_check_mark: | ~~SPLIT node should handle invalid array splt length~~ |
| :white_check_mark: | ~~SPLIT node should handle invalid splt length~~ |
| :white_check_mark: | ~~SPLIT node should handle invalid spltType (not an array)~~ |
| :white_check_mark: | ~~SPLIT node should handle spltBufferString value of undefined~~ |
| :white_check_mark: | ~~SPLIT node should set msg.parts.ch when node.spltType is str~~ |
| :white_check_mark: | ~~SPLIT node should split a buffer into lengths~~ |
| :white_check_mark: | ~~SPLIT node should split a buffer on another buffer (streaming)~~ |
| :white_check_mark: | ~~SPLIT node should split a string into lengths~~ |
| :white_check_mark: | ~~SPLIT node should split a string into new-lines~~ |
| :white_check_mark: | ~~SPLIT node should split a string on a specified char~~ |
| :white_check_mark: | ~~SPLIT node should split a string on a specified char in stream mode~~ |
| :white_check_mark: | ~~SPLIT node should split an array into multiple messages~~ |
| :white_check_mark: | ~~SPLIT node should split an array into multiple messages of a specified size~~ |
| :white_check_mark: | ~~SPLIT node should split an array on a sub-property into multiple messages~~ |
| :white_check_mark: | ~~SPLIT node should split an object into pieces~~ |
| :white_check_mark: | ~~SPLIT node should split an object into pieces and overwrite their topics~~ |
| :white_check_mark: | ~~SPLIT node should split an object sub property into pieces~~ |
| :x: | **JOIN node messaging API should call done() regardless of buffer overflow** |
| :x: | **JOIN node messaging API should call done() when all messages are joined** |
| :x: | **JOIN node messaging API should call done() when all messages are reduced** |
| :x: | **JOIN node messaging API should call done() when consolidated message is emitted (Buffer, bin)** |
| :x: | **JOIN node messaging API should call done() when consolidated message is emitted (Buffer, len)** |
| :x: | **JOIN node messaging API should call done() when consolidated message is emitted (Buffer, str)** |
| :x: | **JOIN node messaging API should call done() when consolidated message is emitted (string, len)** |
| :x: | **JOIN node messaging API should call done() when message is sent (array)** |
| :x: | **JOIN node messaging API should call done() when message is sent (object)** |
| :x: | **JOIN node messaging API should call done() when message is sent (string)** |
| :x: | **JOIN node messaging API should call done() when the node is reset** |
| :x: | **JOIN node messaging API should call done() when timed out** |
| :x: | **JOIN node should accumulate a key/value object** |
| :x: | **JOIN node should accumulate a merged object** |
| :x: | **JOIN node should allow chained split-split-join-join sequences** |
| :x: | **JOIN node should allow the timeout to be restarted** |
| :x: | **JOIN node should be able to reset an accumulation** |
| :x: | **JOIN node should be loaded** |
| :x: | **JOIN node should concat payload when group.type is array** |
| :x: | **JOIN node should concat payload when group.type is buffer and group.joinChar is undefined** |
| :x: | **JOIN node should concat payload when group.type is string and group.joinChar is not string** |
| :x: | **JOIN node should handle invalid JSONata fixup expression - runtime err"** |
| :x: | **JOIN node should handle invalid JSONata fixup expression - syntax err"** |
| :x: | **JOIN node should handle invalid JSONata reduce expression - runtime error"** |
| :x: | **JOIN node should handle invalid JSONata reduce expression - syntax error"** |
| :x: | **JOIN node should handle join an array when mode is auto and duplicate indexed parts arrive** |
| :x: | **JOIN node should handle join an array when using msg.parts and duplicate indexed parts arrive and being reset halfway** |
| :x: | **JOIN node should handle msg.parts even if messages are out of order in auto mode if exactly one message has count set** |
| :x: | **JOIN node should handle msg.parts property when mode is auto and parts or id are missing** |
| :x: | **JOIN node should handle too many pending messages for reduce mode** |
| :x: | **JOIN node should join bits of buffer back together automatically** |
| :x: | **JOIN node should join bits of string back together automatically** |
| :x: | **JOIN node should join bits of string back together automatically with a buffer joiner** |
| :x: | **JOIN node should join complete message objects into an array after a count** |
| :x: | **JOIN node should join split strings back into a word** |
| :x: | **JOIN node should join split things back into an array** |
| :x: | **JOIN node should join split things back into an object** |
| :x: | **JOIN node should join split things, send when told complete** |
| :x: | **JOIN node should join strings into a buffer after a count** |
| :x: | **JOIN node should join strings with a specifed character after a timeout** |
| :x: | **JOIN node should join strings with a specifed character and complete when told to** |
| :x: | **JOIN node should join things into an array after a count** |
| :x: | **JOIN node should join things into an array after a count with a buffer join set** |
| :x: | **JOIN node should join things into an array ignoring msg.parts.index in manual mode** |
| :x: | **JOIN node should join things into an array on a sub property in auto mode** |
| :x: | **JOIN node should join things into an object after a count** |
| :x: | **JOIN node should manually join things into an array, send when told complete** |
| :x: | **JOIN node should manually join things into an object, send when told complete** |
| :x: | **JOIN node should merge full msg objects** |
| :x: | **JOIN node should merge objects** |
| :x: | **JOIN node should merge sub property objects** |
| :x: | **JOIN node should reduce messages** |
| :x: | **JOIN node should reduce messages (left)** |
| :x: | **JOIN node should reduce messages (right)** |
| :x: | **JOIN node should reduce messages - count only in last part** |
| :x: | **JOIN node should reduce messages using $I** |
| :x: | **JOIN node should reduce messages with array result** |
| :x: | **JOIN node should reduce messages with fixup** |
| :x: | **JOIN node should reduce messages with flow context** |
| :x: | **JOIN node should reduce messages with global context** |
| :x: | **JOIN node should reduce messages with init types (JSONata)** |
| :x: | **JOIN node should reduce messages with init types (bin)** |
| :x: | **JOIN node should reduce messages with init types (bool)** |
| :x: | **JOIN node should reduce messages with init types (env)** |
| :x: | **JOIN node should reduce messages with init types (flow.name)** |
| :x: | **JOIN node should reduce messages with init types (global.name)** |
| :x: | **JOIN node should reduce messages with init types (json)** |
| :x: | **JOIN node should reduce messages with init types (num)** |
| :x: | **JOIN node should reduce messages with init types (str)** |
| :x: | **JOIN node should reduce messages with persistable flow context** |
| :x: | **JOIN node should reduce messages with persistable global context** |
### sort node
| Status | Spec Test |
| --- | --- |
| :white_check_mark: | ~~SORT node should be loaded~~ |
| :white_check_mark: | ~~SORT node should clear pending messages on close~~ |
| :white_check_mark: | ~~SORT node should handle JSONata script error~~ |
| :white_check_mark: | ~~SORT node should handle too many pending messages~~ |
| :white_check_mark: | ~~SORT node should sort message group (exp, not number, ascending)~~ |
| :white_check_mark: | ~~SORT node should sort message group (exp, not number, descending)~~ |
| :white_check_mark: | ~~SORT node should sort message group by context (exp, not number, ascending)~~ |
| :white_check_mark: | ~~SORT node should sort message group by persistable context (exp, not number, descending)~~ |
| :white_check_mark: | ~~SORT node should sort message group/payload (not number, ascending)~~ |
| :white_check_mark: | ~~SORT node should sort message group/payload (not number, descending)~~ |
| :white_check_mark: | ~~SORT node should sort message group/payload (number, ascending)~~ |
| :white_check_mark: | ~~SORT node should sort message group/payload (number, descending)~~ |
| :white_check_mark: | ~~SORT node should sort message group/prop (not number, ascending)~~ |
| :white_check_mark: | ~~SORT node should sort message group/prop (not number, descending)~~ |
| :white_check_mark: | ~~SORT node should sort message group/prop (number, ascending)~~ |
| :white_check_mark: | ~~SORT node should sort message group/prop (number, descending)~~ |
| :white_check_mark: | ~~SORT node should sort msg prop (elem, not number, ascending)~~ |
| :white_check_mark: | ~~SORT node should sort msg prop (elem, not number, descending)~~ |
| :white_check_mark: | ~~SORT node should sort msg prop (elem, number, ascending)~~ |
| :white_check_mark: | ~~SORT node should sort msg prop (elem, number, descending)~~ |
| :white_check_mark: | ~~SORT node should sort payload (elem, not number, ascending)~~ |
| :white_check_mark: | ~~SORT node should sort payload (elem, not number, descending)~~ |
| :white_check_mark: | ~~SORT node should sort payload (elem, number, ascending)~~ |
| :white_check_mark: | ~~SORT node should sort payload (elem, number, descending)~~ |
| :white_check_mark: | ~~SORT node should sort payload (exp, not number, ascending)~~ |
| :white_check_mark: | ~~SORT node should sort payload (exp, not number, descending)~~ |
| :white_check_mark: | ~~SORT node should sort payload by context (exp, not number, ascending)~~ |
| :white_check_mark: | ~~SORT node should sort payload by persistable context (exp, not number, descending)~~ |
| :white_check_mark: | ~~SORT node should sort payload of objects~~ |
| :x: | **SORT node messaging API should call done() regardless of buffer overflow (different group)** |
| :x: | **SORT node messaging API should call done() regardless of buffer overflow (same group)** |
| :x: | **SORT node messaging API should call done() when message is sent (payload)** |
| :x: | **SORT node messaging API should call done() when message is sent (sequence)** |
### batch node
| Status | Spec Test |
| --- | --- |
| :white_check_mark: | ~~BATCH node mode: concat should concat same seq.~~ |
| :white_check_mark: | ~~BATCH node mode: concat should concat three seq.~~ |
| :white_check_mark: | ~~BATCH node mode: concat should concat two seq. (mixed)~~ |
| :white_check_mark: | ~~BATCH node mode: concat should concat two seq. (series)~~ |
| :white_check_mark: | ~~BATCH node mode: concat should handle reset~~ |
| :white_check_mark: | ~~BATCH node mode: concat should handle too many pending messages~~ |
| :white_check_mark: | ~~BATCH node mode: count should create seq. with count~~ |
| :white_check_mark: | ~~BATCH node mode: count should create seq. with count (more sent than count)~~ |
| :white_check_mark: | ~~BATCH node mode: count should create seq. with count and overlap~~ |
| :white_check_mark: | ~~BATCH node mode: count should create seq. with count and terminate early if parts honoured~~ |
| :white_check_mark: | ~~BATCH node mode: count should handle reset~~ |
| :white_check_mark: | ~~BATCH node mode: count should handle too many pending messages~~ |
| :white_check_mark: | ~~BATCH node mode: interval should create seq. with interval & not send empty seq~~ |
| :white_check_mark: | ~~BATCH node mode: interval should create seq. with interval & send empty seq~~ |
| :white_check_mark: | ~~BATCH node mode: interval should create seq. with interval (in float)~~ |
| :white_check_mark: | ~~BATCH node mode: interval should handle reset~~ |
| :white_check_mark: | ~~BATCH node mode: interval should handle too many pending messages~~ |
| :white_check_mark: | ~~BATCH node should be loaded with defaults~~ |
| :x: | **BATCH node messaging API should call done() regardless of buffer overflow (mode: concat)** |
| :x: | **BATCH node messaging API should call done() regardless of buffer overflow (mode: count)** |
| :x: | **BATCH node messaging API should call done() regardless of buffer overflow (mode: interval)** |
| :x: | **BATCH node messaging API should call done() when message is sent (mode: concat)** |
| :x: | **BATCH node messaging API should call done() when message is sent (mode: count)** |
| :x: | **BATCH node messaging API should call done() when message is sent (mode: interval)** |
| :x: | **BATCH node messaging API should call done() when reset (mode: concat)** |
| :x: | **BATCH node messaging API should call done() when reset (mode: count)** |
| :x: | **BATCH node messaging API should call done() when reset (mode: interval)** |
| :x: | **BATCH node mode: interval should create seq. with interval** |
## network nodes
### tcp request
| Status | Spec Test |
| --- | --- |
| :white_check_mark: | ~~TCP Request Node many messages should limit the queue size~~ |
| :white_check_mark: | ~~TCP Request Node many messages should only retain the latest message~~ |
| :white_check_mark: | ~~TCP Request Node many messages should send & receive, then keep connection~~ |
| :white_check_mark: | ~~TCP Request Node many messages should send & receive, then keep connection, and not split return strings~~ |
| :white_check_mark: | ~~TCP Request Node many messages should send & receive, then keep connection, and split return strings~~ |
| :white_check_mark: | ~~TCP Request Node many messages should send & receive, then keep connection, and split return strings and reattach delimiter~~ |
| :white_check_mark: | ~~TCP Request Node many messages should send & recv data~~ |
| :white_check_mark: | ~~TCP Request Node many messages should send & recv data after fixed number of chars received~~ |
| :white_check_mark: | ~~TCP Request Node many messages should send & recv data to/from server:port from msg~~ |
| :white_check_mark: | ~~TCP Request Node many messages should send & recv data when specified character received~~ |
| :white_check_mark: | ~~TCP Request Node single message should retain complete message~~ |
| :white_check_mark: | ~~TCP Request Node single message should send & receive, then keep connection~~ |
| :white_check_mark: | ~~TCP Request Node single message should send & recv data~~ |
| :white_check_mark: | ~~TCP Request Node single message should send & recv data after fixed number of chars received~~ |
| :white_check_mark: | ~~TCP Request Node single message should send & recv data to/from server:port from msg~~ |
| :white_check_mark: | ~~TCP Request Node single message should send & recv data when specified character received~~ |
## parser nodes
### json node
| Status | Spec Test |
| --- | --- |
| :white_check_mark: | ~~JSON node msg.schema property should be deleted before sending to next node (object input)~~ |
| :white_check_mark: | ~~JSON node msg.schema property should be deleted before sending to next node (string input)~~ |
| :white_check_mark: | ~~JSON node should convert a array to a json string~~ |
| :white_check_mark: | ~~JSON node should convert a boolean to a json string~~ |
| :white_check_mark: | ~~JSON node should convert a buffer of a valid json string to a javascript object~~ |
| :white_check_mark: | ~~JSON node should convert a javascript object to a json string~~ |
| :white_check_mark: | ~~JSON node should convert a json string to a boolean~~ |
| :white_check_mark: | ~~JSON node should convert a json string to a number~~ |
| :white_check_mark: | ~~JSON node should convert a number to a json string~~ |
| :white_check_mark: | ~~JSON node should convert a valid json string to a javascript object~~ |
| :white_check_mark: | ~~JSON node should ensure the result is a JS Object~~ |
| :white_check_mark: | ~~JSON node should ensure the result is a json string~~ |
| :white_check_mark: | ~~JSON node should handle any msg property - receive existing obj~~ |
| :white_check_mark: | ~~JSON node should handle any msg property - receive existing string~~ |
| :white_check_mark: | ~~JSON node should log an error if asked to parse an invalid json string~~ |
| :white_check_mark: | ~~JSON node should log an error if passed a valid object and invalid schema~~ |
| :white_check_mark: | ~~JSON node should log an error if passed an invalid JSON string and valid schema~~ |
| :white_check_mark: | ~~JSON node should log an error if passed an invalid JSON string and valid schema and action is string~~ |
| :white_check_mark: | ~~JSON node should log an error if passed an invalid object and valid schema~~ |
| :white_check_mark: | ~~JSON node should log an error if passed an invalid object and valid schema and action is object~~ |
| :white_check_mark: | ~~JSON node should pass a string if provided a valid JSON string and schema and action is string~~ |
| :white_check_mark: | ~~JSON node should pass a string if provided a valid object and schema~~ |
| :white_check_mark: | ~~JSON node should pass an object if provided a valid JSON string and schema~~ |
| :white_check_mark: | ~~JSON node should pass an object if provided a valid object and schema and action is object~~ |
| :white_check_mark: | ~~JSON node should pass straight through if no payload set~~ |
| :x: | **JSON node should log an error if asked to parse an invalid json string in a buffer** |
### xml node
| Status | Spec Test |
| --- | --- |
| :white_check_mark: | ~~XML node should be loaded~~ |
| :white_check_mark: | ~~XML node should convert a javascript object to an xml string~~ |
| :white_check_mark: | ~~XML node should convert a javascript object to an xml string with options - alternative property~~ |
| :white_check_mark: | ~~XML node should convert a valid xml string to a javascript object~~ |
| :white_check_mark: | ~~XML node should convert a valid xml string to a javascript object - alternative property~~ |
| :white_check_mark: | ~~XML node should convert a valid xml string to a javascript object with options~~ |
| :white_check_mark: | ~~XML node should just pass through if payload is missing~~ |
| :white_check_mark: | ~~XML node should log an error if asked to parse an invalid xml string~~ |
| :white_check_mark: | ~~XML node should log an error if asked to parse something thats not xml or js~~ |
### csv node
| Status | Spec Test |
| --- | --- |
| :white_check_mark: | ~~CSV node (Legacy Mode) csv to json should convert a simple csv string to a javascript object~~ |
| :white_check_mark: | ~~CSV node (Legacy Mode) csv to json should convert a simple string to a javascript object with space separator (with spaced template)~~ |
| :white_check_mark: | ~~CSV node (Legacy Mode) csv to json should convert a simple string to a javascript object with tab separator (with template)~~ |
| :white_check_mark: | ~~CSV node (Legacy Mode) csv to json should convert a simple string to a javascript object with | separator (no template)~~ |
| :white_check_mark: | ~~CSV node (Legacy Mode) csv to json should remove quotes and whitespace from template~~ |
| :white_check_mark: | ~~CSV node (Legacy Mode) should be loaded with defaults~~ |
| :x: | **CSV node (Legacy Mode) csv to json should allow blank strings in the input if selected** |
| :x: | **CSV node (Legacy Mode) csv to json should allow commas and spaces in the template** |
| :x: | **CSV node (Legacy Mode) csv to json should allow dropping of fields from the template** |
| :x: | **CSV node (Legacy Mode) csv to json should allow missing columns (nulls) in the input if selected** |
| :x: | **CSV node (Legacy Mode) csv to json should allow passing in a template as first line of CSV** |
| :x: | **CSV node (Legacy Mode) csv to json should allow passing in a template as first line of CSV (not comma)** |
| :x: | **CSV node (Legacy Mode) csv to json should allow passing in a template as first line of CSV (special char /)** |
| :x: | **CSV node (Legacy Mode) csv to json should allow passing in a template as first line of CSV (special char \)** |
| :x: | **CSV node (Legacy Mode) csv to json should allow quotes in the input (but drop blank strings)** |
| :x: | **CSV node (Legacy Mode) csv to json should be able to create an array from multiple parts** |
| :x: | **CSV node (Legacy Mode) csv to json should be able to output multiple lines as one array** |
| :x: | **CSV node (Legacy Mode) csv to json should be able to output multiple objects as an array from an input of parts** |
| :x: | **CSV node (Legacy Mode) csv to json should be able to skip and then use the first of multiple parts as a template if parts are present** |
| :x: | **CSV node (Legacy Mode) csv to json should be able to use the first line as a template** |
| :x: | **CSV node (Legacy Mode) csv to json should be able to use the first of multiple parts as a template if parts are present** |
| :x: | **CSV node (Legacy Mode) csv to json should create column names if no template provided** |
| :x: | **CSV node (Legacy Mode) csv to json should handle cr and lf in the input** |
| :x: | **CSV node (Legacy Mode) csv to json should handle numbers in strings but not IP addresses** |
| :x: | **CSV node (Legacy Mode) csv to json should leave handle strings with scientific notation as numbers** |
| :x: | **CSV node (Legacy Mode) csv to json should leave numbers starting with 0, e and + as strings (except 0.)** |
| :x: | **CSV node (Legacy Mode) csv to json should not parse numbers when told not to do so** |
| :x: | **CSV node (Legacy Mode) csv to json should parse numbers when told to do so** |
| :x: | **CSV node (Legacy Mode) csv to json should preserve parts property** |
| :x: | **CSV node (Legacy Mode) csv to json should recover from an odd number of quotes in the input** |
| :x: | **CSV node (Legacy Mode) csv to json should recover from an odd number of quotes in the input (2)** |
| :x: | **CSV node (Legacy Mode) csv to json should skip several lines from start and correct parts** |
| :x: | **CSV node (Legacy Mode) csv to json should skip several lines from start if requested** |
| :x: | **CSV node (Legacy Mode) csv to json should skip several lines from start then use next line as a template** |
| :x: | **CSV node (Legacy Mode) json object to csv should be able to include column names as first row** |
| :x: | **CSV node (Legacy Mode) json object to csv should be able to include column names as first row, and missing properties** |
| :x: | **CSV node (Legacy Mode) json object to csv should be able to pass in column names** |
| :x: | **CSV node (Legacy Mode) json object to csv should be able to pass in column names - with payload as an array** |
| :x: | **CSV node (Legacy Mode) json object to csv should convert a simple array back to a csv** |
| :x: | **CSV node (Legacy Mode) json object to csv should convert a simple object back to a csv** |
| :x: | **CSV node (Legacy Mode) json object to csv should convert a simple object back to a csv with no template** |
| :x: | **CSV node (Legacy Mode) json object to csv should convert a simple object back to a tsv using a tab as a separator** |
| :x: | **CSV node (Legacy Mode) json object to csv should convert an array of arrays back to a multi-line csv** |
| :x: | **CSV node (Legacy Mode) json object to csv should convert an array of objects to a multi-line csv** |
| :x: | **CSV node (Legacy Mode) json object to csv should convert an array of objects to a multi-line csv and add a header** |
| :x: | **CSV node (Legacy Mode) json object to csv should convert an array of objects to a multi-line csv without a template** |
| :x: | **CSV node (Legacy Mode) json object to csv should convert an array of objects to a multi-line csv without a template and with a header** |
| :x: | **CSV node (Legacy Mode) json object to csv should handle a template with quotes in the property names** |
| :x: | **CSV node (Legacy Mode) json object to csv should handle a template with spaces in the property names** |
| :x: | **CSV node (Legacy Mode) json object to csv should handle quotes and sub-properties** |
| :x: | **CSV node (Legacy Mode) should call done when input causes an error** |
| :x: | **CSV node (Legacy Mode) should call done when message processing is completed** |
| :x: | **CSV node (Legacy Mode) should just pass through if no payload provided** |
| :x: | **CSV node (Legacy Mode) should warn if provided a number or boolean** |
| :x: | **CSV node (RFC Mode) csv to json should allow blank strings in the input if selected** |
| :x: | **CSV node (RFC Mode) csv to json should allow commas and spaces in the template** |
| :x: | **CSV node (RFC Mode) csv to json should allow dropping of fields from the template** |
| :x: | **CSV node (RFC Mode) csv to json should allow missing columns (nulls) in the input if selected** |
| :x: | **CSV node (RFC Mode) csv to json should allow passing in a template as first line of CSV** |
| :x: | **CSV node (RFC Mode) csv to json should allow passing in a template as first line of CSV (not comma)** |
| :x: | **CSV node (RFC Mode) csv to json should allow passing in a template as first line of CSV (special char /)** |
| :x: | **CSV node (RFC Mode) csv to json should allow passing in a template as first line of CSV (special char \)** |
| :x: | **CSV node (RFC Mode) csv to json should allow quotes in the input (but drop blank strings)** |
| :x: | **CSV node (RFC Mode) csv to json should be able to create an array from multiple parts** |
| :x: | **CSV node (RFC Mode) csv to json should be able to output multiple lines as one array** |
| :x: | **CSV node (RFC Mode) csv to json should be able to output multiple objects as an array from an input of parts** |
| :x: | **CSV node (RFC Mode) csv to json should be able to skip and then use the first of multiple parts as a template if parts are present** |
| :x: | **CSV node (RFC Mode) csv to json should be able to use the first line as a template** |
| :x: | **CSV node (RFC Mode) csv to json should be able to use the first of multiple parts as a template if parts are present** |
| :x: | **CSV node (RFC Mode) csv to json should convert a simple csv string to a javascript object** |
| :x: | **CSV node (RFC Mode) csv to json should convert a simple string to a javascript object with space separator (with spaced template)** |
| :x: | **CSV node (RFC Mode) csv to json should convert a simple string to a javascript object with tab separator (with template)** |
| :x: | **CSV node (RFC Mode) csv to json should convert a simple string to a javascript object with | separator (no template)** |
| :x: | **CSV node (RFC Mode) csv to json should create column names if no template provided** |
| :x: | **CSV node (RFC Mode) csv to json should handle cr and lf in the input** |
| :x: | **CSV node (RFC Mode) csv to json should handle newlines in the input data** |
| :x: | **CSV node (RFC Mode) csv to json should handle numbers in strings but not IP addresses** |
| :x: | **CSV node (RFC Mode) csv to json should leave handle strings with scientific notation as numbers** |
| :x: | **CSV node (RFC Mode) csv to json should leave numbers starting with 0, e and + as strings (except 0.)** |
| :x: | **CSV node (RFC Mode) csv to json should not parse numbers when told not to do so** |
| :x: | **CSV node (RFC Mode) csv to json should not remove quotes and whitespace from template - should set status and send warning** |
| :x: | **CSV node (RFC Mode) csv to json should parse numbers when told to do so** |
| :x: | **CSV node (RFC Mode) csv to json should preserve parts property** |
| :x: | **CSV node (RFC Mode) csv to json should recover from an odd number of quotes in the input** |
| :x: | **CSV node (RFC Mode) csv to json should skip several lines from start and correct parts** |
| :x: | **CSV node (RFC Mode) csv to json should skip several lines from start if requested** |
| :x: | **CSV node (RFC Mode) csv to json should skip several lines from start then use next line as a template** |
| :x: | **CSV node (RFC Mode) json object to csv should be able to include column names as first row** |
| :x: | **CSV node (RFC Mode) json object to csv should be able to include column names as first row, and missing properties** |
| :x: | **CSV node (RFC Mode) json object to csv should be able to pass in column names** |
| :x: | **CSV node (RFC Mode) json object to csv should be able to pass in column names - with payload as an array** |
| :x: | **CSV node (RFC Mode) json object to csv should convert a simple array back to a csv** |
| :x: | **CSV node (RFC Mode) json object to csv should convert a simple object back to a csv** |
| :x: | **CSV node (RFC Mode) json object to csv should convert a simple object back to a csv with no template** |
| :x: | **CSV node (RFC Mode) json object to csv should convert a simple object back to a tsv using a tab as a separator** |
| :x: | **CSV node (RFC Mode) json object to csv should convert a simple object back to a tsv with headers using a tab as a separator** |
| :x: | **CSV node (RFC Mode) json object to csv should convert an array of arrays back to a multi-line csv** |
| :x: | **CSV node (RFC Mode) json object to csv should convert an array of objects to a multi-line csv** |
| :x: | **CSV node (RFC Mode) json object to csv should convert an array of objects to a multi-line csv and add a header** |
| :x: | **CSV node (RFC Mode) json object to csv should convert an array of objects to a multi-line csv without a template** |
| :x: | **CSV node (RFC Mode) json object to csv should convert an array of objects to a multi-line csv without a template and with a header** |
| :x: | **CSV node (RFC Mode) json object to csv should handle a template with quotes in the property names** |
| :x: | **CSV node (RFC Mode) json object to csv should handle a template with spaces in the property names** |
| :x: | **CSV node (RFC Mode) json object to csv should handle quotes and sub-properties** |
| :x: | **CSV node (RFC Mode) should be loaded with defaults** |
| :x: | **CSV node (RFC Mode) should call done when message processing is completed** |
| :x: | **CSV node (RFC Mode) should just pass through if no payload provided** |
| :x: | **CSV node (RFC Mode) should not call done or pass the bad msg through when input causes an error - should throw error and set status** |
| :x: | **CSV node (RFC Mode) should warn if provided a number or boolean** |
### yaml node
| Status | Spec Test |
| --- | --- |
| :white_check_mark: | ~~YAML node should be loaded~~ |
| :white_check_mark: | ~~YAML node should convert a javascript object to a yaml string~~ |
| :white_check_mark: | ~~YAML node should convert a valid yaml string to a javascript object~~ |
| :white_check_mark: | ~~YAML node should convert a valid yaml string to a javascript object - using another property~~ |
| :x: | **YAML node should convert a javascript object to a yaml string - using another property** |
| :x: | **YAML node should convert an array to a yaml string** |
| :x: | **YAML node should log an error if asked to parse an invalid yaml string** |
| :x: | **YAML node should log an error if asked to parse something thats not yaml or js** |
| :x: | **YAML node should pass straight through if no payload set** |
## subflow
### subflow
| Status | Spec Test |
| --- | --- |
| :white_check_mark: | ~~subflow should access NR_NODE_PATH env var within subflow instance~~ |
| :white_check_mark: | ~~subflow should access env var of group~~ |
| :white_check_mark: | ~~subflow should access env var of nested group~~ |
| :white_check_mark: | ~~subflow should access env var of parent subflow instance~~ |
| :white_check_mark: | ~~subflow should access env var of parent subflow template~~ |
| :white_check_mark: | ~~subflow should access env var of subflow instance~~ |
| :white_check_mark: | ~~subflow should access env var of subflow template~~ |
| :white_check_mark: | ~~subflow should access env var of tab~~ |
| :white_check_mark: | ~~subflow should access last env var with same name~~ |
| :white_check_mark: | ~~subflow should access typed value of env var~~ |
| :white_check_mark: | ~~subflow should define subflow~~ |
| :white_check_mark: | ~~subflow should overwrite env var of subflow template by env var of subflow instance~~ |
| :white_check_mark: | ~~subflow should pass data to/from nested subflow~~ |
| :white_check_mark: | ~~subflow should pass data to/from subflow~~ |
